// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <iterator>

namespace std::experimental
{
namespace meta {
inline namespace v1 {
	 
// FIXME: Find a better way of forcing constexpr errors.

struct compile_time_error { };

// Like assert, but always runs and guarantees non-compilation.
constexpr! void require(bool b) {
  if (!b)
    throw compile_time_error();
}

// An opaque handle to a reflected entity.
//
// FIXME: This should be an enum class, but those don't 
// readily convert to bool. Most likely, this should be a 
// special type that prevents all forms of construction 
// but value construction.
enum info : std::intptr_t { };

// TODO: Keep this in sync and in order with the 
// corresponding enum in ExprConstant.cpp.
enum reflection_kind {
  null_construct = 0,

  // Declarations
  translation_unit,
  namespace_decl,
  variable_decl,
  function_decl,
  parameter_decl,
  class_decl,
  data_member_decl,
  member_function_decl,
  access_spec,
  enum_decl,
  enumerator_decl,

  // Types
  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
};

// Kinds of linkage.
enum linkage_kind {
  external_linkage,
  internal_linkage,
  no_linkage,
};

// Kinds of (detectable) storage duration.
enum storage_kind {
  automatic_storage,
  thread_storage,
  static_storage,
};

// Kinds of class types.
enum class_key {
  struct_key,
  class_key,
  union_key
};

// Kinds of access.
enum access_kind {
  public_access,
  protected_access,
  private_access,
  no_access,
};

// Kinds of member functions.
enum memun_kind {
  normal,
  constructor,
  destructor,
  conversion,
};

// Kind and kind testing

// Returns the kind (discriminator) of the meta info.
constexpr! reflection_kind kind(info x) {
  return (reflection_kind)__reflect_index(x); 
}

// True if x is a null reflection.
constexpr! bool is_null(info x) {
  return kind(x) == null_construct;
}

// True if x reflects a declaration.
//
// TODO: Make sure this stays in agreement with reflection_kind.
constexpr! bool is_declaration(info x) {
  reflection_kind k = kind(x);
  return translation_unit <= k && k <= enumerator_decl;
}

// True if x reflects a fundamental or non-user-defined type.
constexpr! bool is_type(info x) {
  reflection_kind k = kind(x);
  return void_type <= k && k <= array_type;
}

// True if x reflects a translation unit.
constexpr! bool is_translation_unit(info x) {
  return kind(x) == translation_unit;
}

// True if x reflects a namespace.
constexpr! bool is_namespace(info x) {
  return kind(x) == namespace_decl;
}

// True if x reflects a variable.
constexpr! bool is_variable(info x) {
  return kind(x) == variable_decl;
}

// True if x reflects a function.
constexpr! bool is_function(info x) {
  return kind(x) == function_decl;
}

// True if x reflects a parameter.
constexpr! bool is_parameter(info x) {
  return kind(x) == parameter_decl;
}

// True if x reflects a class.
constexpr! bool is_class(info x) {
  return kind(x) == class_decl;
}

// True if x reflects a data member.
constexpr! bool is_data_member(info x) {
  return kind(x) == data_member_decl;
}

// True if x reflects a member function.
constexpr! bool is_member_function(info x) {
  return kind(x) == member_function_decl;
}

// True if x reflects an access specifier.
constexpr! bool is_access_specifier(info x) {
  return kind(x) == access_spec;
}

// True if x reflections an enum.
constexpr! bool is_enum(info x) {
  return kind(x) == enum_decl;
}

// True if x reflects an enumerator.
constexpr! bool is_enumerator(info x) {
  return kind(x) == enumerator_decl;
}

// -------------------------------------------------------------------------- //
// Traversal queries
	 
// Returns the lexical context of the declaration.
constexpr! info parent(info x) {
  return __reflect_context(x);
  return {};
}

// Returns the home context of the declaration.
constexpr! info home(info x) {
  return __reflect_home(x);
  return {};
}

class iterator {
public:
  using value_type = info;
  using reference = info;
  using pointer = info;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  constexpr! iterator() : curr() { }
  constexpr! iterator(info x) : curr(x) { }

  constexpr! info operator*() const { return curr; }
  constexpr! info operator->() const { return curr; }

  constexpr! iterator& operator++() { 
    if (!is_null(curr))
      curr = __reflect_next(curr); 
    return *this;
  }

  constexpr! iterator operator++(int) {
    iterator tmp = *this;
    operator++();
    return tmp;
  }

  constexpr! bool operator==(iterator i) const { return curr == i.curr; }
  constexpr! bool operator!=(iterator i) const { return curr != i.curr; }

private:  
  info curr;
};

// Returns the first sub-object of x. Objects behave 
// as forward iterators.
constexpr! iterator begin(info x) {
  return iterator(__reflect_begin(x));
  return {};
}

// Returns a null sub-object of x, indicating 
// the end of a sequence.
//
// FIXME: This seems to mean that we don't actually need __reflect_end.
constexpr! iterator end(info x) {
  return iterator();
}

// Returns the first child of declaration context. This can be used with
// next() to traverse contexts as template arguments (iterators don't work
// as template arguments).
constexpr! info front(info x) {
  return __reflect_begin(x);
  return {};
}

// Returns the next info in the sequence.
constexpr! info next(info x) {
  return __reflect_next(x);
  return {};
}

// Overload distance so that it's constexpr!.
constexpr! std::ptrdiff_t distance(iterator first, iterator last) {
  std::ptrdiff_t n = 0;
  for (; first != last; ++first)
    ++n;
  return n;
}

// -------------------------------------------------------------------------- //
// Traversal queries

// True if x is a member of a class.
constexpr! bool is_class_member(info x) {
  return is_class(parent(x));
}

// -------------------------------------------------------------------------- //
// Name

constexpr! const char* name(info x) {
  return __reflect_name(x);
  return "";
}

// -------------------------------------------------------------------------- //
// Type

// Returns the reflected type of a variable or function.
constexpr! info type(info x) {
  return __reflect_type(x);
  return {};
}

// -------------------------------------------------------------------------- //
// Declaration traits

struct namespace_traits {
  constexpr! explicit namespace_traits(unsigned n)
    : is_inline(n)
  { }

  constexpr! explicit namespace_traits(info x)
    : namespace_traits(__reflect_traits(x))
  { require(is_namespace(x)); }
  
  unsigned is_inline : 1;
};

// FIXME: A variable can be declared but not defined.
struct variable_traits {
  constexpr! explicit variable_traits(unsigned n) 
    : linkage(n),
      storage(n >> 2),
      is_static(n >> 4),
      is_extern(n >> 5),
      is_inline(n >> 6),
      is_constexpr(n >> 7)
  { }

  constexpr! explicit variable_traits(info x)
    : variable_traits(__reflect_traits(x))
  { require(is_variable(x)); }
  
  unsigned linkage : 2;
  unsigned storage : 2;
  unsigned is_static : 1;
  unsigned is_extern : 1;
  unsigned is_inline : 1;
  unsigned is_constexpr : 1;
};

struct function_traits {
  constexpr! explicit function_traits(unsigned n) 
    : linkage(n), 
      is_static(n >> 2),
      is_extern(n >> 3),
      is_constexpr(n >> 4),
      is_defined(n >> 5),
      is_inline(n >> 6), 
      is_deleted(n >> 7)
  { }

  constexpr! explicit function_traits(info x)
    : function_traits(__reflect_traits(x))
  { require(is_function(x)); }
  
  unsigned linkage : 2;
  unsigned is_static : 1;
  unsigned is_extern : 1;
  unsigned is_constexpr : 1;
  unsigned is_defined : 1;
  unsigned is_inline : 1;
  unsigned is_deleted : 1;
};

struct class_traits {
  constexpr! explicit class_traits(unsigned n) 
    : linkage(n),
      access(n >> 2),
      key(n >> 4),
      is_complete(n >> 6),
      is_injected(n >> 7)
  { }

  constexpr! explicit class_traits(info x)
    : class_traits(__reflect_traits(x))
  { }
  
  unsigned linkage : 2;
  unsigned access : 2;
  unsigned key : 2;
  unsigned is_complete : 1;
  unsigned is_injected : 1;
};

struct data_member_traits {
  constexpr! explicit data_member_traits(unsigned n) 
    : storage(n), 
      access(n >> 2),
      is_static(n >> 4),
      is_mutable(n >> 5),
      is_inline(n >> 6),
      is_constexpr(n >> 7),
      is_bitfield(n >> 8)
  { }

  constexpr! explicit data_member_traits(info x)
    : data_member_traits(__reflect_traits(x))
  { require(is_data_member(x)); }
  
  unsigned storage : 2;
  unsigned access : 2;
  unsigned is_static : 1;
  unsigned is_mutable : 1;
  unsigned is_inline : 1;
  unsigned is_constexpr : 1;
  unsigned is_bitfield : 1;
};

struct member_function_traits {
  constexpr! explicit member_function_traits(unsigned n) 
    : access(n),
      kind(n >> 2),
      is_static(n >> 4),
      is_constexpr(n >> 5),
      is_explicit(n >> 6),
      is_virtual(n >> 7),
      is_pure(n >> 8),
      is_override(n >> 9),
      is_final(n >> 10),
      is_defined(n >> 11),
      is_inline(n >> 12),
      is_deleted(n >> 13),
      is_defaulted(n >> 14)
  { }

  constexpr! explicit member_function_traits(info x)
    : member_function_traits(__reflect_traits(x))
  { require(is_member_function(x)); }

  unsigned access : 2;
  unsigned kind : 2;
  unsigned is_static : 1;
  unsigned is_constexpr : 1;
  unsigned is_explicit : 1;
  unsigned is_virtual : 1;
  unsigned is_pure : 1;
  unsigned is_override : 1;
  unsigned is_final : 1;
  unsigned is_defined : 1;
  unsigned is_inline : 1;
  unsigned is_deleted : 1;
  unsigned is_defaulted : 1;
};

struct enum_traits {
  constexpr! explicit enum_traits(unsigned n) 
    : linkage(n),
      access(n >> 2),
      is_scoped(n >> 4)
  { }

  constexpr! explicit enum_traits(info x)
    : enum_traits(__reflect_traits(x))
  { require(is_enum(x)); }
  
  unsigned linkage : 2;
  unsigned access : 2;
  unsigned is_scoped : 1;
};

struct enumerator_traits {
  constexpr! explicit enumerator_traits(unsigned n) 
    : access(n)
  { }

  constexpr! explicit enumerator_traits(info x)
    : enumerator_traits(__reflect_traits(x))
  { }
  
  unsigned access : 2;
};

// -------------------------------------------------------------------------- //
// Access specifiers

struct access_traits {
  constexpr! explicit access_traits(unsigned n) 
    : access(n)
  { }
  
  constexpr! explicit access_traits(info x)
    : access_traits(__reflect_traits(x))
  { }
  
  unsigned access : 2;
};

// -------------------------------------------------------------------------- //
// General purpose queries

constexpr! bool has_linkage(info x) {
  switch (kind(x)) {
  case namespace_decl:
    return true;
  case variable_decl:
    return variable_traits(x).linkage != no_linkage;
  case function_decl:
    return function_traits(x).linkage != no_linkage;
  case class_decl:
    return class_traits(x).linkage != no_linkage;
  case enum_decl:
    return enum_traits(x).linkage != no_linkage;
  default:
    __builtin_unreachable();
  }
}

constexpr! bool has_external_linkage(info x) {
  switch (kind(x)) {
    case namespace_decl:
      return true;
    case variable_decl:
      return variable_traits(x).linkage == external_linkage;
    case function_decl:
      return function_traits(x).linkage == external_linkage;
    case class_decl:
      return class_traits(x).linkage == external_linkage;
    case enum_decl:
      return enum_traits(x).linkage == external_linkage;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool has_internal_linkage(info x) {
  switch (kind(x)) {
    case namespace_decl:
      return false;
    case variable_decl:
      return variable_traits(x).linkage == internal_linkage;
    case function_decl:
      return function_traits(x).linkage == internal_linkage;
    case class_decl:
      return class_traits(x).linkage == internal_linkage;
    case enum_decl:
      return enum_traits(x).linkage == internal_linkage;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool has_automatic_storage(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).storage == automatic_storage;
    case data_member_decl:
      return data_member_traits(x).storage == automatic_storage;
    default:
      __builtin_unreachable();
  }  
}

constexpr! bool has_static_storage(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).storage == static_storage;
    case data_member_decl:
      return data_member_traits(x).storage == static_storage;
    default:
      __builtin_unreachable();
  }  
}

constexpr! bool has_thread_storage(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).storage == thread_storage;
    case data_member_decl:
      return data_member_traits(x).storage == thread_storage;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool has_access(info x) {
  switch (kind(x)) {
    default:
      return false;
    case data_member_decl:
    case member_function_decl:
    case access_spec:
      return true;
    case class_decl:
      return class_traits(x).access != no_access;
    case enum_decl:
      return class_traits(x).access != no_access;
    case enumerator_decl:
      return enumerator_traits(x).access != no_access;
  }
}

// True if x's access specifier is determined by the default access of
// the enclosing class.
constexpr bool has_default_access(info x) {
  assert(is_class_member(x));
  for (info m : parent(x)) {
    if (is_access_specifier(m))
      return false;
    if (m == x)
      return true;
  }
  __builtin_unreachable();
}

constexpr! bool is_public(info x) {
  assert(has_access(x));
  switch (kind(x)) {
    case data_member_decl:
      return data_member_traits(x).access ==  public_access;
    case member_function_decl:
      return member_function_traits(x).access ==  public_access;
    case access_spec:
      return access_traits(x).access ==  public_access;
    case class_decl:
      return class_traits(x).access == public_access;
    case enum_decl:
      return class_traits(x).access == public_access;
    case enumerator_decl:
      return enumerator_traits(x).access == public_access;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_private(info x) {
  assert(has_access(x));
  switch (kind(x)) {
    case data_member_decl:
      return data_member_traits(x).access ==  private_access;
    case member_function_decl:
      return member_function_traits(x).access ==  private_access;
    case access_spec:
      return access_traits(x).access ==  private_access;
    case class_decl:
      return class_traits(x).access == private_access;
    case enum_decl:
      return class_traits(x).access == private_access;
    case enumerator_decl:
      return enumerator_traits(x).access == private_access;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_protected(info x) {
  assert(has_access(x));
  switch (kind(x)) {
    case data_member_decl:
      return data_member_traits(x).access ==  protected_access;
    case member_function_decl:
      return member_function_traits(x).access ==  protected_access;
    case access_spec:
      return access_traits(x).access ==  protected_access;
    case class_decl:
      return class_traits(x).access == protected_access;
    case enum_decl:
      return class_traits(x).access == protected_access;
    case enumerator_decl:
      return enumerator_traits(x).access == protected_access;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_static(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).is_static;
    case function_decl:
      return function_traits(x).is_static;
    case data_member_decl:
      return data_member_traits(x).is_static;
    case member_function_decl:
      return member_function_traits(x).is_static;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_extern(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).is_extern;
    case function_decl:
      return function_traits(x).is_extern;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_inline(info x) {
  switch (kind(x)) {
    case namespace_decl:
      return namespace_traits(x).is_inline;
    case variable_decl:
      return variable_traits(x).is_inline;
    case function_decl:
      return function_traits(x).is_inline;
    case data_member_decl:
      return data_member_traits(x).is_inline;
    case member_function_decl:
      return member_function_traits(x).is_inline;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_constexpr(info x) {
  switch (kind(x)) {
    case variable_decl:
      return variable_traits(x).is_constexpr;
    case function_decl:
      return function_traits(x).is_constexpr;
    case data_member_decl:
      return data_member_traits(x).is_constexpr;
    case member_function_decl:
      return member_function_traits(x).is_constexpr;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_normal(info x) {
  return member_function_traits(x).kind == normal;
}

constexpr! bool is_constructor(info x) {
  return member_function_traits(x).kind == constructor;
}

constexpr! bool is_destructor(info x) {
  return member_function_traits(x).kind == destructor;
}

constexpr! bool is_conversion(info x) {
  return member_function_traits(x).kind == conversion;
}

constexpr! bool is_explicit(info x) {
  return member_function_traits(x).is_explicit;
}

constexpr! bool is_virtual(info x) {
  return member_function_traits(x).is_virtual;
}

constexpr! bool is_pure_virtual(info x) {
  return member_function_traits(x).is_pure;
}

constexpr! bool is_override(info x) {
  return member_function_traits(x).is_override;
}

constexpr! bool is_final(info x) {
  return member_function_traits(x).is_final;
}

constexpr! bool is_defaulted(info x) {
  return member_function_traits(x).is_defaulted;
}

constexpr! bool is_mutable(info x) {
  return data_member_traits(x).is_mutable;
}

// TODO: Add an accessor for the bit width.
constexpr! bool is_bitfield(info x) {
  return data_member_traits(x).is_bitfield;
}

constexpr! bool is_defined(info x) {
  switch (kind(x)) {
    case variable_decl:
      // FIXME: This is not accurate.
      return !is_extern(x);
    case function_decl:
      return function_traits(x).is_defined;
    case class_decl:
      return class_traits(x).is_complete;
    case data_member_decl:
      return true;
    case member_function_decl:
      return member_function_traits(x).is_defined;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_deleted(info x) {
  switch (kind(x)) {
    case function_decl:
      return function_traits(x).is_deleted;
    case member_function_decl:
      return member_function_traits(x).is_deleted;
    default:
      __builtin_unreachable();
  }
}

constexpr! bool is_declared_struct(info x) {
  return class_traits(x).key == struct_key;
}

constexpr! bool is_declared_class(info x) {
  return class_traits(x).key == class_key;
}

constexpr! bool is_union(info x) {
  return class_traits(x).key == union_key;
}

constexpr! bool is_complete(info x) {
  return class_traits(x).is_complete;
}

constexpr! bool is_injected_class_name(info x) {
  return class_traits(x).is_injected;
}

constexpr! bool is_scoped(info x) {
  return enum_traits(x).is_scoped;
}

} // inline namespace v1
} // namespace meta
} // namespace std::experimental


#endif // CPPX_META
